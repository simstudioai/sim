---
title: ブロック参照構文
description: YAMLワークフローでブロック間のデータを参照する方法
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'

ブロック参照はSimワークフローにおけるデータフローの基盤です。あるブロックの出力を別のブロックの入力として正しく参照する方法を理解することは、機能的なワークフローを構築するために不可欠です。

## 基本的な参照ルール

### 1. ブロックIDではなくブロック名を使用する

<Tabs items={['正しい例', '間違った例']}>
  <Tab>

    ```yaml
    # Block definition
    email-sender:
      type: agent
      name: "Email Generator"
      # ... configuration

    # Reference the block
    next-block:
      inputs:
        userPrompt: "Process this: <emailgenerator.content>"
    ```

  </Tab>
  <Tab>

    ```yaml
    # Block definition
    email-sender:
      type: agent
      name: "Email Generator"
      # ... configuration

    # ❌ Don't reference by block ID
    next-block:
      inputs:
        userPrompt: "Process this: <email-sender.content>"
    ```

  </Tab>
</Tabs>

### 2. 名前を参照形式に変換する

ブロック参照を作成するには：

1. **ブロック名を取得する**：「Email Generator」
2. **小文字に変換する**：「email generator」
3. **スペースと特殊文字を削除する**：「emailgenerator」
4. **プロパティを追加する**：`<emailgenerator.content>`

### 3. 正しいプロパティを使用する

ブロックタイプによって異なるプロパティが公開されます：

- **エージェントブロック**：`.content` (AI応答)
- **関数ブロック**：`.output` (戻り値)
- **APIブロック**：`.output` (レスポンスデータ)
- **ツールブロック**：`.output` (ツール結果)

## 参照例

### 一般的なブロック参照

```yaml
# Agent block outputs
<agentname.content>           # Primary AI response
<agentname.tokens>            # Token usage information
<agentname.cost>              # Estimated cost
<agentname.tool_calls>        # Tool execution details

# Function block outputs  
<functionname.output>         # Function return value
<functionname.error>          # Error information (if any)

# API block outputs
<apiname.output>              # Response data
<apiname.status>              # HTTP status code
<apiname.headers>             # Response headers

# Tool block outputs
<toolname.output>             # Tool execution result
```

### 複数単語のブロック名

```yaml
# Block name: "Data Processor 2"
<dataprocessor2.output>

# Block name: "Email Validation Service"  
<emailvalidationservice.output>

# Block name: "Customer Info Agent"
<customerinfoagent.content>
```

## 特殊な参照ケース

### スタータブロック

<Callout type="warning">
  スタータブロックは、実際の名前に関係なく、常に `<start.input>` として参照されます。
</Callout>

```yaml
# Starter block definition
my-custom-start:
  type: starter
  name: "Custom Workflow Start"
  # ... configuration

# Always reference as 'start'
agent-1:
  inputs:
    userPrompt: <start.input>  # ✅ Correct
    # userPrompt: <customworkflowstart.input>  # ❌ Wrong
```

### ループ変数

ループブロック内では、特別な変数が利用できます：

```yaml
# Available in loop child blocks
<loop.index>          # Current iteration (0-based)
<loop.currentItem>    # Current item being processed (forEach loops)
<loop.items>          # Full collection (forEach loops)
```

### 並列処理変数

並列ブロック内では、特別な変数が利用できます：

```yaml
# Available in parallel child blocks
<parallel.index>          # Instance number (0-based)
<parallel.currentItem>    # Item for this instance
<parallel.items>          # Full collection
```

## 複雑な参照例

### ネストされたデータアクセス

複雑なオブジェクトを参照する場合は、ドット表記を使用します：

```yaml
# If an agent returns structured data
data-analyzer:
  type: agent
  name: "Data Analyzer"
  inputs:
    responseFormat: |
      {
        "schema": {
          "type": "object",
          "properties": {
            "analysis": {"type": "object"},
            "summary": {"type": "string"},
            "metrics": {"type": "object"}
          }
        }
      }

# Reference nested properties
next-step:
  inputs:
    userPrompt: |
      Summary: <dataanalyzer.analysis.summary>
      Score: <dataanalyzer.metrics.score>
      Full data: <dataanalyzer.content>
```

### テキスト内の複数参照

```yaml
email-composer:
  type: agent
  inputs:
    userPrompt: |
      Create an email with the following information:
      
      Customer: <customeragent.content>
      Order Details: <orderprocessor.output>
      Support Ticket: <ticketanalyzer.content>
      
      Original request: <start.input>
```

### コードブロック内の参照

関数ブロック内で参照を使用すると、JavaScript値として置き換えられます：

```yaml
data-processor:
  type: function
  inputs:
    code: |
      // References are replaced with actual values
      const customerData = <customeragent.content>;
      const orderInfo = <orderprocessor.output>;
      const originalInput = <start.input>;
      
      // Process the data
      return {
        customer: customerData.name,
        orderId: orderInfo.id,
        processed: true
      };
```

## 参照の検証

SimはYAMLをインポートする際にすべての参照を検証します：

### 有効な参照
- ブロックがワークフロー内に存在する
- プロパティがブロックタイプに適している
- 循環依存関係がない
- 適切な構文フォーマット

### 一般的なエラー
- **ブロックが見つからない**：参照されたブロックが存在しない
- **プロパティの誤り**：関数ブロックで `.content` を使用
- **タイプミス**：ブロック名やプロパティのスペルミス
- **循環参照**：ブロックが直接または間接的に自身を参照している

## ベストプラクティス

1. **説明的なブロック名を使用する**：参照をより読みやすくする
2. **一貫性を保つ**：同じ命名規則をすべてに適用する
3. **参照をチェックする**：参照されるすべてのブロックが存在することを確認する
4. **深いネストを避ける**：参照チェーンを管理しやすく保つ
5. **複雑なフローを文書化する**：参照関係を説明するコメントを追加する