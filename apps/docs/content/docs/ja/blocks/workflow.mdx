---
title: ワークフロー
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Step, Steps } from 'fumadocs-ui/components/steps'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Image } from '@/components/ui/image'

ワークフローブロックを使用すると、現在のワークフロー内で他のワークフローを再利用可能なコンポーネントとして実行できます。これにより、モジュール式の設計、コードの再利用、そして小規模で焦点を絞ったワークフローから構成される複雑なネストされたワークフローの作成が可能になります。

<div className="flex justify-center">
  <Image
    src="/static/blocks/workflow.png"
    alt="ワークフローブロック"
    width={500}
    height={350}
    className="my-6"
  />
</div>

<Callout type="info">
  ワークフローブロックは、小規模で再利用可能なコンポーネントから複雑なワークフローを構成できるようにすることで、モジュール式の設計を可能にします。
</Callout>

## 概要

ワークフローブロックはワークフロー間の橋渡しとして機能し、以下のことを可能にします：

<Steps>
  <Step>
    <strong>既存のワークフローを再利用する</strong>：以前に作成したワークフローを新しいワークフロー内のコンポーネントとして実行する
  </Step>
  <Step>
    <strong>モジュール式の設計を作成する</strong>：複雑なプロセスを小さく管理しやすいワークフローに分解する
  </Step>
  <Step>
    <strong>関心の分離を維持する</strong>：異なるビジネスロジックを別々のワークフローに分離して保持する
  </Step>
  <Step>
    <strong>チームコラボレーションを可能にする</strong>：異なるプロジェクトやチームメンバー間でワークフローを共有し再利用する
  </Step>
</Steps>

## 動作の仕組み

ワークフローブロックは：

1. ワークスペース内の別のワークフローへの参照を取得します
2. 現在のワークフローから子ワークフローに入力データを渡します（start.inputを通じて利用可能）
3. 子ワークフローを分離されたコンテキストで実行します
4. 結果を親ワークフローに返して、さらに処理を行います

## 設定オプション

### ワークフローの選択

ワークスペースで利用可能なワークフローのドロップダウンリストから実行するワークフローを選択します。リストには以下が含まれます：

- 現在のワークスペースでアクセスできるすべてのワークフロー
- チームの他のメンバーから共有されたワークフロー
- 有効および無効の両方のワークフロー（ただし実行できるのは有効なワークフローのみ）

### 実行コンテキスト

子ワークフローは以下の条件で実行されます：

- 独自の分離された実行コンテキスト
- 同じワークスペースリソース（APIキー、環境変数）へのアクセス
- 適切なワークスペースメンバーシップと権限チェック
- 実行ログ内のネストされたトレーススパン

<Callout type="warning">
  **循環検出**: システムは自動的にワークフロー間の循環依存関係を検出し、無限ループを防止します。
</Callout>

## 入力と出力

<Tabs items={['Configuration', 'Variables', 'Results']}>
  <Tab>
    <ul className="list-disc space-y-2 pl-6">
      <li>
        <strong>ワークフロー選択</strong>: 実行するワークフローを選択
      </li>
      <li>
        <strong>入力データ</strong>: 子ワークフローに渡す変数またはブロック参照
      </li>
      <li>
        <strong>実行コンテキスト</strong>: ワークスペースリソースを持つ分離環境
      </li>
    </ul>
  </Tab>
  <Tab>
    <ul className="list-disc space-y-2 pl-6">
      <li>
        <strong>workflow.success</strong>: 完了ステータスを示すブール値
      </li>
      <li>
        <strong>workflow.childWorkflowName</strong>: 実行された子ワークフローの名前
      </li>
      <li>
        <strong>workflow.result</strong>: 子ワークフローから返された結果
      </li>
      <li>
        <strong>workflow.error</strong>: ワークフローが失敗した場合のエラー詳細
      </li>
    </ul>
  </Tab>
  <Tab>
    <ul className="list-disc space-y-2 pl-6">
      <li>
        <strong>ワークフローレスポンス</strong>: 子ワークフローからの主要な出力
      </li>
      <li>
        <strong>実行ステータス</strong>: 成功ステータスとエラー情報
      </li>
      <li>
        <strong>アクセス</strong>: ワークフロー後のブロックで利用可能
      </li>
    </ul>
  </Tab>
</Tabs>

## 使用例

### モジュール式顧客オンボーディング

<div className="mb-4 rounded-md border p-4">
  <h4 className="font-medium">シナリオ: 複雑なオンボーディングを再利用可能なコンポーネントに分解</h4>
  <ol className="list-decimal pl-5 text-sm">
    <li>メインワークフローが顧客データを受信</li>
    <li>ワークフローブロックが検証ワークフローを実行</li>
    <li>ワークフローブロックがアカウント設定ワークフローを実行</li>
    <li>ワークフローブロックが歓迎メールワークフローを実行</li>
  </ol>
</div>

### マイクロサービスアーキテクチャ

<div className="mb-4 rounded-md border p-4">
  <h4 className="font-medium">シナリオ: 独立したサービスワークフローを作成</h4>
  <ol className="list-decimal pl-5 text-sm">
    <li>決済処理ワークフローがトランザクションを処理</li>
    <li>在庫管理ワークフローが在庫を更新</li>
    <li>通知ワークフローが確認を送信</li>
    <li>メインワークフローがすべてのサービスを調整</li>
  </ol>
</div>

### 条件付き処理

<div className="mb-4 rounded-md border p-4">
  <h4 className="font-medium">シナリオ：条件に基づいて異なるワークフローを実行する</h4>
  <ol className="list-decimal pl-5 text-sm">
    <li>条件ブロックがユーザータイプを評価</li>
    <li>エンタープライズユーザー → 複雑な承認ワークフロー</li>
    <li>標準ユーザー → シンプルな承認ワークフロー</li>
    <li>無料ユーザー → 基本的な処理ワークフロー</li>
  </ol>
</div>

## ベストプラクティス

- **ワークフローを集中させる**：子ワークフローは明確な入力と出力を持つ特定の、明確に定義されたタスクを処理するように設計する
- **ネストの深さを最小限に抑える**：保守性とパフォーマンスを向上させるため、深くネストされたワークフロー階層を避ける
- **エラーを適切に処理する**：子ワークフローの失敗に対する適切なエラー処理を実装し、フォールバックメカニズムを提供する
- **独立してテストする**：子ワークフローが親ワークフローから独立してテストおよび検証できることを確認する
- **セマンティックな命名を使用する**：ワークフローには目的と機能を明確に示す説明的な名前を付ける
