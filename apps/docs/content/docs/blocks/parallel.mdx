---
title: Parallel
description: Execute multiple blocks concurrently for faster workflow processing
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Step, Steps } from 'fumadocs-ui/components/steps'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { ThemeImage } from '@/components/ui/theme-image'

The Parallel block is a container block in Sim Studio that allows you to execute multiple instances of blocks concurrently. This enables faster processing of independent operations and efficient distribution of work across multiple executions.

<ThemeImage
  lightSrc="/static/light/parallel-light.png"
  darkSrc="/static/dark/parallel-dark.png"
  alt="Parallel Block"
  width={300}
  height={175}
/>

<Callout type="info">
  Parallel blocks are container nodes that execute their contents multiple times simultaneously, unlike loops which execute sequentially.
</Callout>

## Overview

The Parallel block enables you to:

<Steps>
  <Step>
    <strong>Distribute work</strong>: Process multiple items concurrently
  </Step>
  <Step>
    <strong>Speed up execution</strong>: Run independent operations simultaneously
  </Step>
  <Step>
    <strong>Handle bulk operations</strong>: Process large datasets efficiently
  </Step>
  <Step>
    <strong>Aggregate results</strong>: Collect outputs from all parallel executions
  </Step>
</Steps>

## Configuration Options

### Parallel Type

Choose between two types of parallel execution:

<Tabs items={['Count-based', 'Collection-based']}>
  <Tab>
    Execute a fixed number of parallel instances. Use this when you need to run the same operation multiple times concurrently.
    
    ```
    Example: Run 5 parallel instances
    - Instance 1 ┐
    - Instance 2 ├─ All execute simultaneously
    - Instance 3 │
    - Instance 4 │
    - Instance 5 ┘
    ```
  </Tab>
  <Tab>
    Distribute a collection across parallel instances. Each instance processes one item from the collection simultaneously.
    
    ```
    Example: Process ["task1", "task2", "task3"] in parallel
    - Instance 1: Process "task1" ┐
    - Instance 2: Process "task2" ├─ All execute simultaneously
    - Instance 3: Process "task3" ┘
    ```
  </Tab>
</Tabs>

### Configuration Parameters

- **Count** (Count-based): Number of parallel instances to run (1-20)
- **Collection** (Collection-based): Array or object to distribute across instances

## How to Use Parallel Blocks

### Creating a Parallel Block

1. Drag a Parallel block from the toolbar onto your canvas
2. Configure the parallel type and parameters
3. Drag other blocks inside the parallel container
4. Connect the blocks as needed

### Accessing Parallel Data

Inside a parallel block, you can access special variables:

- **`<parallel.currentItem>`**: The item assigned to this instance (Collection-based)
- **`<parallel.index>`**: The instance number (0-based)
- **`<parallel.items>`**: The full collection being distributed (Collection-based)

### Accessing Results

After a parallel block completes, you can access aggregated results:

- **`<parallel.results>`**: Array of results from all parallel instances

## Example Use Cases

### Batch API Processing

<div className="mb-4 rounded-md border p-4">
  <h4 className="font-medium">Scenario: Process multiple API calls simultaneously</h4>
  <ol className="list-decimal pl-5 text-sm">
    <li>Parallel block with collection of API endpoints</li>
    <li>Inside parallel: API block calls each endpoint</li>
    <li>Inside parallel: Function processes each response</li>
    <li>After parallel: Aggregate all results</li>
  </ol>
</div>

### Multi-Model AI Processing

<div className="mb-4 rounded-md border p-4">
  <h4 className="font-medium">Scenario: Get responses from multiple AI models</h4>
  <ol className="list-decimal pl-5 text-sm">
    <li>Count-based parallel set to 3 instances</li>
    <li>Inside parallel: Agent with different model per instance</li>
    <li>After parallel: Compare and select best response</li>
  </ol>
</div>

### Data Enrichment Pipeline

<div className="mb-4 rounded-md border p-4">
  <h4 className="font-medium">Scenario: Enrich multiple records simultaneously</h4>
  <ol className="list-decimal pl-5 text-sm">
    <li>Collection-based parallel with customer records</li>
    <li>Inside parallel: API enriches each record</li>
    <li>Inside parallel: Agent analyzes enriched data</li>
    <li>After parallel: Combine all enriched records</li>
  </ol>
</div>

## Advanced Features

### Result Aggregation

Results from all parallel instances are automatically collected:

```javascript
// In a Function block after the parallel
const allResults = input.parallel.results;
// Returns: [result1, result2, result3, ...]
```

### Instance Isolation

Each parallel instance runs independently:
- Separate variable scopes
- No shared state between instances
- Failures in one instance don't affect others

### Performance Considerations

<Callout type="warning">
  While parallel execution is faster, be mindful of:
  - API rate limits when making concurrent requests
  - Memory usage with large datasets
  - Maximum of 20 concurrent instances to prevent resource exhaustion
</Callout>

## Parallel vs Loop

Understanding when to use each:

| Feature | Parallel | Loop |
|---------|----------|------|
| Execution | Concurrent | Sequential |
| Speed | Faster for independent operations | Slower but ordered |
| Order | No guaranteed order | Maintains order |
| Use case | Independent operations | Dependent operations |
| Resource usage | Higher | Lower |

## Best Practices

- **Independent operations only**: Ensure operations don't depend on each other
- **Handle rate limits**: Add delays or throttling for API-heavy workflows
- **Aggregate thoughtfully**: Plan how to combine results from all instances
- **Monitor resources**: Watch execution times and costs with many instances
- **Error handling**: Each instance should handle its own errors gracefully

<Callout type="info">
  Parallel blocks are ideal for operations that can run independently. If operations depend on previous results, use a Loop block instead.
</Callout>

## Inputs and Outputs

<Tabs items={['Configuration', 'Variables', 'Results']}>
  <Tab>
    <ul className="list-disc space-y-2 pl-6">
      <li>
        <strong>Parallel Type</strong>: Choose between 'count' or 'collection'
      </li>
      <li>
        <strong>Count</strong>: Number of instances to run (count-based)
      </li>
      <li>
        <strong>Collection</strong>: Array or object to distribute (collection-based)
      </li>
    </ul>
  </Tab>
  <Tab>
    <ul className="list-disc space-y-2 pl-6">
      <li>
        <strong>parallel.currentItem</strong>: Item for this instance
      </li>
      <li>
        <strong>parallel.index</strong>: Instance number (0-based)
      </li>
      <li>
        <strong>parallel.items</strong>: Full collection (collection-based)
      </li>
    </ul>
  </Tab>
  <Tab>
    <ul className="list-disc space-y-2 pl-6">
      <li>
        <strong>parallel.results</strong>: Array of all instance results
      </li>
      <li>
        <strong>Structure</strong>: Results maintain instance order
      </li>
      <li>
        <strong>Access</strong>: Available in blocks after the parallel
      </li>
    </ul>
  </Tab>
</Tabs>

## Tips and Tricks

- **Combine with loops**: Use a loop inside a parallel for multi-dimensional processing
- **Dynamic distribution**: Generate collections from API responses or functions
- **Partial results**: Handle scenarios where some instances might fail
- **Progress tracking**: Monitor completion of parallel instances for long operations 