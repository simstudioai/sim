---
title: Function
description: Execute custom JavaScript or TypeScript code in your workflows
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Step, Steps } from 'fumadocs-ui/components/steps'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { ThemeImage } from '@/components/ui/theme-image'

The Function block lets you run custom JavaScript or TypeScript code in your workflow. Use it to transform data, perform calculations, or implement custom logic that isn't available in other blocks.

<ThemeImage
  lightSrc="/static/light/function-light.png"
  darkSrc="/static/dark/function-dark.png"
  alt="Function Block with Code Editor"
  width={350}
  height={175}
/>

## What You Can Do

**Transform Data**: Convert formats, parse text, manipulate arrays and objects
**Perform Calculations**: Math operations, statistics, financial calculations
**Custom Logic**: Complex conditionals, loops, and algorithms
**Process APIs**: Parse responses, format requests, handle authentication
**Validate Data**: Check formats, validate business rules, sanitize input

## How It Works

The Function block runs your code in a secure, isolated environment:

1. **Receive Input**: Access data from previous blocks via the `input` object
2. **Execute Code**: Run your JavaScript/TypeScript code 
3. **Return Results**: Use `return` to pass data to the next block
4. **Handle Errors**: Built-in error handling and logging

## Configuration Options

### Code Editor

Write your JavaScript/TypeScript code in a full-featured editor with:
- Syntax highlighting and error checking
- Autocomplete and IntelliSense
- Line numbers and bracket matching
- Support for modern JavaScript features

<ThemeImage
  lightSrc="/static/light/function-light.png"
  darkSrc="/static/dark/function-dark.png"
  alt="Code Editor Interface"
  width={600}
  height={350}
/>

### Accessing Input Data

Use the `input` object to access data from previous blocks:

```javascript
// Access data from connected blocks
const userData = input.userData;
const orderData = input.orderData;

// Access specific fields
const customerName = input.customer.name;
const total = input.order.total;
```

### Common Examples

**Data Transformation**:
```javascript
// Convert and format data
const formatted = {
  name: input.user.firstName + ' ' + input.user.lastName,
  email: input.user.email.toLowerCase(),
  joinDate: new Date(input.user.created).toLocaleDateString()
};
return formatted;
```

**Calculations**:
```javascript
// Calculate discounts and totals
const subtotal = input.items.reduce((sum, item) => sum + item.price, 0);
const discount = subtotal > 100 ? 0.1 : 0;
const total = subtotal * (1 - discount);

return { subtotal, discount, total };
```

**Data Validation**:
```javascript
// Validate email format
const email = input.email;
const isValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

if (!isValid) {
  throw new Error('Invalid email format');
}
return { email, isValid };
```

## Security and Limitations

Functions run in a secure environment with these restrictions:

- **Execution timeout**: 30 seconds maximum to prevent infinite loops
- **Memory limits**: Limited memory to prevent resource exhaustion  
- **No network access**: Cannot make HTTP requests (use API blocks instead)
- **Limited APIs**: Only safe JavaScript APIs are available

## Inputs and Outputs

**Inputs**:
- **Code**: Your JavaScript/TypeScript code to execute
- **Input Data**: All connected block outputs available via the `input` object
- **Timeout**: Maximum execution time (optional, defaults to 30 seconds)

**Outputs**:
- **Result**: The value you return from your function
- **Stdout**: Any console.log() output from your code (useful for debugging)

## Example Usage

Here's an example of a Function block that processes customer data and calculates a loyalty score:

```javascript
// Example Function Block Code
// Process customer data and calculate loyalty score

// Access input from previous blocks
const { purchaseHistory, accountAge, supportTickets } = input;

// Calculate metrics
const totalSpent = purchaseHistory.reduce((sum, purchase) => sum + purchase.amount, 0);
const purchaseFrequency = purchaseHistory.length / (accountAge / 365);
const ticketRatio = supportTickets.resolved / supportTickets.total;

// Calculate loyalty score (0-100)
const spendScore = Math.min(totalSpent / 1000 * 30, 30);
const frequencyScore = Math.min(purchaseFrequency * 20, 40);
const supportScore = ticketRatio * 30;

const loyaltyScore = Math.round(spendScore + frequencyScore + supportScore);

// Return results
return {
  customer: input.name,
  loyaltyScore,
  loyaltyTier: loyaltyScore >= 80 ? "Platinum" : loyaltyScore >= 60 ? "Gold" : loyaltyScore >= 40 ? "Silver" : "Bronze",
  metrics: {
    spendScore,
    frequencyScore,
    supportScore
  }
};
```

## Best Practices

- **Keep functions focused**: Write functions that do one thing well
- **Handle errors gracefully**: Use try/catch blocks to handle potential errors
- **Document your code**: Add comments to explain complex logic
- **Test edge cases**: Ensure your code handles unusual inputs correctly
- **Optimize for performance**: Be mindful of computational complexity for large datasets
