---
title: Block-Referenz-Syntax
description: Wie man Daten zwischen Blöcken in YAML-Workflows referenziert
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'

Block-Referenzen sind die Grundlage des Datenflusses in Sim-Workflows. Das Verständnis, wie man Ausgaben von einem Block korrekt als Eingaben für einen anderen referenziert, ist essenziell für den Aufbau funktionaler Workflows.

## Grundlegende Referenzregeln

### 1. Verwende Blocknamen, nicht Block-IDs

<Tabs items={['Correct', 'Incorrect']}>
  <Tab>

    ```yaml
    # Block definition
    email-sender:
      type: agent
      name: "Email Generator"
      # ... configuration

    # Reference the block
    next-block:
      inputs:
        userPrompt: "Process this: <emailgenerator.content>"
    ```

  </Tab>
  <Tab>

    ```yaml
    # Block definition
    email-sender:
      type: agent
      name: "Email Generator"
      # ... configuration

    # ❌ Don't reference by block ID
    next-block:
      inputs:
        userPrompt: "Process this: <email-sender.content>"
    ```

  </Tab>
</Tabs>

### 2. Namen in Referenzformat umwandeln

Um eine Block-Referenz zu erstellen:

1. **Nimm den Blocknamen**: "Email Generator"
2. **Konvertiere zu Kleinbuchstaben**: "email generator" 
3. **Entferne Leerzeichen und Sonderzeichen**: "emailgenerator"
4. **Füge Eigenschaft hinzu**: `<emailgenerator.content>`

### 3. Verwende die richtigen Eigenschaften

Verschiedene Blocktypen stellen unterschiedliche Eigenschaften bereit:

- **Agent-Blöcke**: `.content` (die KI-Antwort)
- **Funktionsblöcke**: `.output` (der Rückgabewert)
- **API-Blöcke**: `.output` (die Antwortdaten)
- **Tool-Blöcke**: `.output` (das Tool-Ergebnis)

## Referenzbeispiele

### Häufige Block-Referenzen

```yaml
# Agent block outputs
<agentname.content>           # Primary AI response
<agentname.tokens>            # Token usage information
<agentname.cost>              # Estimated cost
<agentname.tool_calls>        # Tool execution details

# Function block outputs  
<functionname.output>         # Function return value
<functionname.error>          # Error information (if any)

# API block outputs
<apiname.output>              # Response data
<apiname.status>              # HTTP status code
<apiname.headers>             # Response headers

# Tool block outputs
<toolname.output>             # Tool execution result
```

### Blocknamen mit mehreren Wörtern

```yaml
# Block name: "Data Processor 2"
<dataprocessor2.output>

# Block name: "Email Validation Service"  
<emailvalidationservice.output>

# Block name: "Customer Info Agent"
<customerinfoagent.content>
```

## Spezielle Referenzfälle

### Starter-Block

<Callout type="warning">
  Der Starter-Block wird immer als `<start.input>` referenziert, unabhängig von seinem tatsächlichen Namen.
</Callout>

```yaml
# Starter block definition
my-custom-start:
  type: starter
  name: "Custom Workflow Start"
  # ... configuration

# Always reference as 'start'
agent-1:
  inputs:
    userPrompt: <start.input>  # ✅ Correct
    # userPrompt: <customworkflowstart.input>  # ❌ Wrong
```

### Schleifenvariablen

Innerhalb von Schleifenblöcken sind spezielle Variablen verfügbar:

```yaml
# Available in loop child blocks
<loop.index>          # Current iteration (0-based)
<loop.currentItem>    # Current item being processed (forEach loops)
<loop.items>          # Full collection (forEach loops)
```

### Parallele Variablen

Innerhalb von parallelen Blöcken sind spezielle Variablen verfügbar:

```yaml
# Available in parallel child blocks
<parallel.index>          # Instance number (0-based)
<parallel.currentItem>    # Item for this instance
<parallel.items>          # Full collection
```

## Komplexe Referenzbeispiele

### Zugriff auf verschachtelte Daten

Bei der Referenzierung komplexer Objekte wird die Punktnotation verwendet:

```yaml
# If an agent returns structured data
data-analyzer:
  type: agent
  name: "Data Analyzer"
  inputs:
    responseFormat: |
      {
        "schema": {
          "type": "object",
          "properties": {
            "analysis": {"type": "object"},
            "summary": {"type": "string"},
            "metrics": {"type": "object"}
          }
        }
      }

# Reference nested properties
next-step:
  inputs:
    userPrompt: |
      Summary: <dataanalyzer.analysis.summary>
      Score: <dataanalyzer.metrics.score>
      Full data: <dataanalyzer.content>
```

### Mehrere Referenzen im Text

```yaml
email-composer:
  type: agent
  inputs:
    userPrompt: |
      Create an email with the following information:
      
      Customer: <customeragent.content>
      Order Details: <orderprocessor.output>
      Support Ticket: <ticketanalyzer.content>
      
      Original request: <start.input>
```

### Referenzen in Codeblöcken

Bei der Verwendung von Referenzen in Funktionsblöcken werden diese als JavaScript-Werte ersetzt:

```yaml
data-processor:
  type: function
  inputs:
    code: |
      // References are replaced with actual values
      const customerData = <customeragent.content>;
      const orderInfo = <orderprocessor.output>;
      const originalInput = <start.input>;
      
      // Process the data
      return {
        customer: customerData.name,
        orderId: orderInfo.id,
        processed: true
      };
```

## Referenzvalidierung

Sim validiert alle Referenzen beim Importieren von YAML:

### Gültige Referenzen
- Block existiert im Workflow
- Eigenschaft ist für den Blocktyp geeignet
- Keine zirkulären Abhängigkeiten
- Korrekte Syntaxformatierung

### Häufige Fehler
- **Block nicht gefunden**: Referenzierter Block existiert nicht
- **Falsche Eigenschaft**: Verwendung von `.content` in einem Funktionsblock
- **Tippfehler**: Falsch geschriebene Blocknamen oder Eigenschaften
- **Zirkuläre Referenzen**: Block referenziert sich direkt oder indirekt selbst

## Best Practices

1. **Verwende beschreibende Blocknamen**: Macht Referenzen lesbarer
2. **Sei konsistent**: Verwende die gleiche Namenskonvention durchgängig
3. **Überprüfe Referenzen**: Stelle sicher, dass alle referenzierten Blöcke existieren
4. **Vermeide tiefe Verschachtelungen**: Halte Referenzketten überschaubar
5. **Dokumentiere komplexe Abläufe**: Füge Kommentare hinzu, um Referenzbeziehungen zu erklären